# minishell

### 입력받는 인자들
1. 명령어 (echo, cd 등)
2. 옵션 (-n 등)
3. 파이프 (|)
4. 리다이렉션 (<, >, >>)
5. 명령어(1)와 옵션(2)을 감싸는 따옴표(''), 쌍따옴표("")
6. 명령어를 구분하는 세미콜론(;)

### 예외로 생각해볼 수 있는 사항(구현x)
1. 따옴표나 쌍따옴표가 홀수개로 들어가는 경우 echo "hello""
2. escape문자(\\)의 기능들

### 환경변수
1. 환경변수는 변수 + 값 으로 구성되어있음
~~~zsh
HOME=Users/tapark
#변수(variable) : HOME
#값(value) : Users/tapark
~~~
2. $(변수) 호출 시 값이 호출됨
~~~zsh
HOME=Users/tapark
echo HOME  #result : HOME
echo $HOME #result : Users/tapark
~~~

### 토큰을 나누는 기준
1. input을 기준문자(세미콜론, 리다이렉션, 파이프) 기준으로 나눈다
2. 나눠진 input에서 기준문자 포함 여부을 체크
3. input을 공백 기준으로 토큰화
4. 환경변수의 경우 공백과 이퀄(=) 기준으로 토큰화
 - 이퀄(=)문자또한 토큰으로 분류?
5. 각 토큰에 대하여 쌍따옴표나 따옴표가 붙는경우 어떻게 되는지?
6. 각 토큰에 대하여 앞 또는 뒤에 공백문자가 붙는경우 어떻게 되는지?
7. 토큰에는 더이상 처리할 것 없는 깨끗한 값이 들어오는 것이 좋은가?
8. 쌍따옴표나 따옴표 기준으로 토큰화를 한다면 예외발생
 - "echo""123" 의 경우 실제 명령어는 실행안됨(echo123)
9. 공백을 기준으로 나눈 후 쌍따옴표와 따옴표 처리?

### 인자 파싱 아이디어(?)
1. 연결리스트1(예시)
~~~C
input$> "echo" -n 'abc2' >>
typedef struct      s_input
{
    char            *token;     //토큰 저장 (echo)
    int             qt;         // 따옴표 존재 유무 (0, 1)
    int             dqt;        // 쌍따옴표 존재 유무 (0, 1)
    int             pipe;       // 파이프 존재 유무 (0, 1)
    int             re;         // 리다이렉션 존재 및 방향 (0, 1, 2)
    int             dre;        // 더블다이렉션 존재 유무 (0, 1)
    sturct s_input  *next;      // (input의 다음 토큰 정보 주소)
}                   t_input;
//문제점 : 리다이렉션이나 파이프에 대한 처리가 까다로워 질듯함
//"echo" -n 'abc2' >> cat 같은경우 4번째 리스트에 도달해야 파이프의 존재 유무를 확인할 수있음
~~~

2. 연결리스트1 + 추가의견
 - 리스트 노드 1개당 토큰 1개가 아닌 토큰 여러개를 저장한다면?
 - 기준문자(세미콜론, 리다이렉션, 파이프) 기준으로 나눠진 input의 토큰들을 저장
 - 그렇다면 2차원 배열에 저장하는 경우 char *token -> char **token
 - 세미콜론의 존재여부또한 체크해주면 좋을듯? int semi


### 기록
 - 5/14 : env, export, unset, exit 기본기능 구현
